# Taller Individual  3
## Reactive Stream

**Semana**: 9

**Objetivos**:

- Aplicar los conocimientos sobre Reactive Stream.
- Generar y procesar flujos de datos reactivos.



### DescripciÃ³n:

Resuelva los siguientes problemas.

### Problema 1
**SincronizaciÃ³n de Sensores**

DescripciÃ³n: Simula dos sensores que emiten valores periÃ³dicos:

- Sensor1: Rango [20Â°C, 30Â°C], cada 1 segundo.
- Sensor2: Rango [30Â°C, 40Â°C], cada 1.5 segundos.
- Usa zip para combinar los valores de ambos sensores en un solo flujo.
- DetÃ©n el flujo despuÃ©s de 10 pares de valores.
- Genera una alerta si la diferencia absoluta entre las lecturas de Sensor1 y Sensor2 es mayor a 5Â°C.
  

```mathematica
Sensor1: 22Â°C, Sensor2: 27Â°C, Difference: 5Â°C
Sensor1: 24Â°C, Sensor2: 34Â°C, Difference: 10Â°C
ğŸš¨ ALERT! Significant difference detected: 10Â°C
```

Se genera los dos sensores en **Sensor1** y **Sensor2** con el rango de valores entre 20 y 30 del sensor1 y de 30 y 40 del sensor 2
```
  //genera los sensores por cada intervalo de tiempo
  private val sensorn1 = Observable.interval(1.second).map(_ => Random.between(20, 30))
  private val sensorn2 = Observable.interval(1.5.second).map(_ => Random.between(30, 40))

```
Luego se crea el zip que tomara ambas variables el Sensor1 y Sensor2 luego se hara un .take para la cantidad de valores que se crearan en un lapso de tiempo para que el problema no solo ejecute el primero o de plano no ejecute ninguno ya que posteriorr a esto 
```
sensorn1.zip(sensorn2)
    .take(10)
```
Luego de haber puesto los valores que queremos tomar agregamos un .subscribe que es el cargado de hacer que toda nuestra logica interna del zip se ejecute.
Posterior a la creacion de subscribe Crearemos el onNext Donde prondremos todo lo que nosotros vamos a imprimir y tambien estara la alogica por ejemplo usar un if para saver si la temperatura del sensor1 tiene una diferencia mayor a 5 grados con respecto al sensor2.
Finalmente ponemos el onError para poder verificar para que no se ejecuten errores y para cuando se acabe o mejor diche finalice la creacion de todas las variabeles usamon onCompleted para poder saber cuando se acabo sin olvidar que hay que poner un Thread.sleep para poder hacer que se ejecuten todos los valores por el tiempo que se tarda 
```
  sensorn1.zip(sensorn2)
    .take(10)
    .subscribe(onNext = { case (temp1, temp2) =>
      //Imprimimos los valores actuales para referencia
      println(s"Lectura: Sensor1: $temp1Â°C, Sensor2: $temp2Â°C, Diferencia: ${(temp1 - temp2).abs} Â°C")

      //Calculamos la diferencia absoluta y verificamos si es mayor a 5
      if ((temp1 - temp2).abs > 5) {
        println(s"ğŸš¨ ALERTA: La diferencia es de ${(temp1 - temp2).abs}Â°C ")//Imprime la alerta
      }
    },
      onError = e => println(s"Error: ${e.getMessage}"),
      onCompleted = () => println("Se completo la tarea") )
  Thread.sleep(20000)

```

Codigo completo 
```
package Bim2Semana9

import rx.lang.scala.Observable
import scala.concurrent.duration._
import scala.util.Random

object Problema_1 extends App{
  //genera los sensores por cada intervalo de tiempo
  private val sensorn1 = Observable.interval(1.second).map(_ => Random.between(20, 30))
  private val sensorn2 = Observable.interval(1.5.second).map(_ => Random.between(30, 40))

  sensorn1.zip(sensorn2)
    .take(10)
    .subscribe(onNext = { case (temp1, temp2) =>
      //Imprimimos los valores actuales para referencia
      println(s"Lectura: Sensor1: $temp1Â°C, Sensor2: $temp2Â°C, Diferencia: ${(temp1 - temp2).abs} Â°C")

      //Calculamos la diferencia absoluta y verificamos si es mayor a 5
      if ((temp1 - temp2).abs > 5) {
        println(s"ğŸš¨ ALERTA: La diferencia es de ${(temp1 - temp2).abs}Â°C ")//Imprime la alerta
      }
    },
      onError = e => println(s"Error: ${e.getMessage}"),
      onCompleted = () => println("Se completo la tarea") )
  Thread.sleep(20000)

}

```
Resultado del codigo 
<img width="718" height="784" alt="image" src="https://github.com/user-attachments/assets/ac12d9a5-ec10-4ba4-804a-d874689286db" />

### Problema 2
**Sistema de Alerta Complejo**

DescripciÃ³n: Simula tres sensores que emiten datos periÃ³dicos:

- Sensor1: Temperatura (20Â°C a 30Â°C).
- Sensor2: Humedad (40% a 60%).
- Sensor3: PresiÃ³n (950 hPa a 1050 hPa).
- Combina los datos de los tres sensores y detecta si alguna de las mÃ©tricas estÃ¡ fuera de rango.
- DetÃ©n el flujo despuÃ©s de 20 combinaciones.

```yaml
Temperature: 22Â°C, Humidity: 50%, Pressure: 970 hPa
Temperature: 25Â°C, Humidity: 42%, Pressure: 1055 hPa
ğŸš¨ ALERT! Pressure out of range: 1055 hPa
...
```

Se genera los dos sensores en **Sensor1**, **Sensor2** y **Sensor3** con el rango de valores entre 20 y 30 del sensor1 y de 30 y 40 del sensor 2
```
  private val sensorn1 = Observable.interval(1.second).map(_ => Random.between(10, 40))
  private val sensorn2 = Observable.interval(1.second).map(_ => Random.between(30, 80))
  private val sensorn3 = Observable.interval(1.second).map(_ => Random.between(900, 1200))
 

```
Luego se crea el zip que tomara ambas variables el Sensor1 , Sensor2 y Sensor3. Ademas como son 3 valores los cuales vamos a hacerle un zip debemos agruparlos ya que el .zip solo revisa dos valores asi se agrupa y considera que 3 valores como 2 valores  luego se hara un .take para la cantidad de valores que se crearan en un lapso de tiempo para que el problema no solo ejecute el primero o de plano no ejecute ninguno ya que posteriorr a esto 
```
 sensorn1.zip(sensorn2).zip(sensorn3)
    .take(20)
    onNext = { case ((tempS1, humedadS2), presS3) =>
```
Luego de haber puesto los valores que queremos tomar agregamos un .subscribe que es el cargado de hacer que toda nuestra logica interna del zip se ejecute.
Posterior a la creacion de subscribe Crearemos el onNext Donde prondremos todo lo que nosotros vamos a imprimir y tambien estara la alogica por ejemplo usar un if para saver si la temperatura del sensor1 tiene una diferencia mayor a 5 grados con respecto al sensor2.
Finalmente ponemos el onError para poder verificar para que no se ejecuten errores y para cuando se acabe o mejor diche finalice la creacion de todas las variabeles usamon onCompleted para poder saber cuando se acabo sin olvidar que hay que poner un Thread.sleep para poder hacer que se ejecuten todos los valores por el tiempo que se tarda 
```
 .subscribe(
      onNext = { case ((tempS1, humedadS2), presS3) =>
      // Imprimimos la lectura general
     
      println(s"Temperature: $tempS1Â°C, Humidity: $humedadS2%, Pressure: $presS3 hPa")

      // Validar Temperatura
      if (tempS1 < 20 || tempS1 > 30) {
        println(s"ğŸš¨ ALERT! Temperature out of range: $tempS1Â°C")
      }

      // Validar Humedad 
      if (humedadS2 < 40 || humedadS2 > 60) {
        println(s"ğŸš¨ ALERT! Humidity out of range: $humedadS2%")
      }

      // Validar PresiÃ³n 
      if (presS3 < 950 || presS3 > 1050) {
        println(s"ğŸš¨ ALERT! Pressure out of range: $presS3 hPa")
      }

    
    },
      onError = e => println(s"Error: ${e.getMessage}"),
      onCompleted = () => println("Se completo la tarea!"))
  Thread.sleep(20000)


```
Codigo completo 
```
package Bim2Semana9

import rx.lang.scala.Observable

import scala.concurrent.duration.*
import scala.language.postfixOps
import scala.util.Random

object Problema_2 extends App{
  //genera los sensores por cada intervalo de tiempo
  private val sensorn1 = Observable.interval(1.second).map(_ => Random.between(10, 40))
  private val sensorn2 = Observable.interval(1.second).map(_ => Random.between(30, 80))
  private val sensorn3 = Observable.interval(1.second).map(_ => Random.between(900, 1200))
  sensorn1.zip(sensorn2).zip(sensorn3)
    .take(20)
    .subscribe(
      onNext = { case ((tempS1, humedadS2), presS3) =>
      // Imprimimos la lectura general
     
      println(s"Temperature: $tempS1Â°C, Humidity: $humedadS2%, Pressure: $presS3 hPa")

      // Validar Temperatura
      if (tempS1 < 20 || tempS1 > 30) {
        println(s"ğŸš¨ ALERT! Temperature out of range: $tempS1Â°C")
      }

      // Validar Humedad 
      if (humedadS2 < 40 || humedadS2 > 60) {
        println(s"ğŸš¨ ALERT! Humidity out of range: $humedadS2%")
      }

      // Validar PresiÃ³n 
      if (presS3 < 950 || presS3 > 1050) {
        println(s"ğŸš¨ ALERT! Pressure out of range: $presS3 hPa")
      }

    
    },
      onError = e => println(s"Error: ${e.getMessage}"),
      onCompleted = () => println("Se completo la tarea!"))
  Thread.sleep(20000)

}

```


Resultado esperado
<img width="727" height="809" alt="image" src="https://github.com/user-attachments/assets/c737bba1-e721-4a42-a3f8-26d60cd64ffe" />

### CalificaciÃ³n:

Para la calificaciÃ³n, se debe presentar el trabajo realizado a su tutor. Es necesario recalcar que la presentaciÃ³n se hace una Ãºnica vez, no existe la posibilidad de presentaciones adicionales con correcciones.

- 10 puntos si presenta en el horario de prÃ¡cticas y experimentaciÃ³n.
- 7 puntos presenta en el horario de tutorÃ­a

La hora mÃ¡xima de presentaciÃ³n serÃ¡ las 08h30
